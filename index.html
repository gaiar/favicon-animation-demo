<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Favicon Animation Lab</title>
    <link id="favicon" rel="icon" type="image/png" href="assets/favicon_32.png">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: system-ui, sans-serif;
            background: #0a0a15;
            color: #fff;
            min-height: 100vh;
            padding: 1.5rem;
        }
        .container { max-width: 1000px; margin: 0 auto; }
        h1 {
            text-align: center;
            font-size: 1.8rem;
            margin-bottom: 0.5rem;
            background: linear-gradient(135deg, #ff6900, #ff3366);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        .subtitle { text-align: center; color: #666; margin-bottom: 2rem; }

        .controls {
            background: #12121f;
            border: 2px solid #ff6900;
            border-radius: 12px;
            padding: 1.5rem;
            margin-bottom: 2rem;
        }
        .controls h2 { text-align: center; margin-bottom: 1rem; font-size: 1rem; }

        .btn-grid {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            justify-content: center;
            margin-bottom: 1rem;
        }
        button {
            background: #1a1a2a;
            color: #fff;
            border: 1px solid #333;
            padding: 0.5rem 0.8rem;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.8rem;
        }
        button:hover { background: #252535; }
        button.active { border-color: #ff6900; box-shadow: 0 0 10px rgba(255,105,0,0.3); }
        button.sound::after { content: " ðŸ”Š"; }
        button.chaos { background: linear-gradient(45deg, #9333ea, #dc2626); }

        .sliders {
            display: flex;
            gap: 2rem;
            justify-content: center;
            flex-wrap: wrap;
            margin: 1rem 0;
        }
        .slider { display: flex; align-items: center; gap: 0.5rem; }
        .slider label { color: #888; font-size: 0.8rem; }
        .slider input { width: 100px; }
        .slider span { color: #ff6900; font-size: 0.8rem; min-width: 40px; }

        .preview-row {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 1.5rem;
            margin-top: 1rem;
            padding: 1rem;
            background: #1a1a2a;
            border-radius: 8px;
        }
        .preview-item { text-align: center; }
        .preview-item canvas {
            background: #fff;
            border-radius: 4px;
            display: block;
            margin: 0 auto 0.3rem;
        }
        .preview-item small { color: #666; font-size: 0.7rem; }

        .info {
            background: #12121f;
            border: 1px solid #333;
            border-radius: 8px;
            padding: 1rem;
            margin-top: 2rem;
            font-size: 0.8rem;
            color: #888;
        }
        .info strong { color: #ff6900; }

        .sound-badge {
            position: fixed;
            top: 1rem;
            right: 1rem;
            background: #dc2626;
            padding: 0.5rem 1rem;
            border-radius: 6px;
            font-size: 0.8rem;
            display: none;
        }

        #current-name {
            text-align: center;
            font-size: 1.2rem;
            margin: 1rem 0;
            color: #ff6900;
        }
    </style>
</head>
<body>
    <div class="sound-badge" id="sound-badge">ðŸ”Š Sound Playing</div>

    <div class="container">
        <h1>Favicon Animation Lab</h1>
        <p class="subtitle">15 experiments - watch your browser tab!</p>

        <div class="controls">
            <h2>Select Animation</h2>
            <div class="btn-grid" id="buttons"></div>

            <div id="current-name">Static</div>

            <div class="sliders">
                <div class="slider">
                    <label>Speed:</label>
                    <input type="range" id="speed" min="0.2" max="5" step="0.1" value="1">
                    <span id="speed-val">1.0x</span>
                </div>
                <div class="slider">
                    <label>Intensity:</label>
                    <input type="range" id="intensity" min="0.2" max="2" step="0.1" value="1">
                    <span id="intensity-val">100%</span>
                </div>
                <div class="slider">
                    <label>Volume:</label>
                    <input type="range" id="volume" min="0" max="1" step="0.1" value="0.3">
                    <span id="volume-val">30%</span>
                </div>
            </div>

            <div class="preview-row">
                <div class="preview-item">
                    <canvas id="preview-64" width="64" height="64"></canvas>
                    <small>64px</small>
                </div>
                <div class="preview-item">
                    <canvas id="preview-32" width="32" height="32"></canvas>
                    <small>32px (favicon)</small>
                </div>
                <div class="preview-item">
                    <canvas id="preview-16" width="16" height="16"></canvas>
                    <small>16px</small>
                </div>
            </div>
        </div>

        <div class="info">
            <strong>Animations:</strong> Static, Pulse, Heartbeat, Spin, Bounce, Drunk, Glitch, Fire, Matrix, Earthquake, Meltdown, PossessedðŸ”Š, TV DeathðŸ”Š, HypnoticðŸ”Š, NIGHTMAREðŸ”Š
            <br><br>
            <strong>Note:</strong> Sound requires user interaction to start (browser security). The favicon in your browser tab updates in real-time!
        </div>
    </div>

<script>
const ANIMS = [
    { id: 'none', name: 'Static' },
    { id: 'pulse', name: 'Pulse' },
    { id: 'heartbeat', name: 'Heartbeat' },
    { id: 'spin', name: 'Spin' },
    { id: 'bounce', name: 'Bounce' },
    { id: 'drunk', name: 'Drunk' },
    { id: 'glitch', name: 'Glitch' },
    { id: 'fire', name: 'Fire' },
    { id: 'matrix', name: 'Matrix' },
    { id: 'earthquake', name: 'Earthquake' },
    { id: 'meltdown', name: 'Meltdown' },
    { id: 'possessed', name: 'Possessed', sound: 'drone', chaos: true },
    { id: 'static', name: 'TV Death', sound: 'noise', chaos: true },
    { id: 'hypnotic', name: 'Hypnotic', sound: 'pulse', chaos: true },
    { id: 'nightmare', name: 'NIGHTMARE', sound: 'chaos', chaos: true },
];

let current = 'none';
let speed = 1;
let intensity = 1;
let volume = 0.3;
let audioCtx, soundNodes;

const img = new Image();
img.crossOrigin = 'anonymous';
img.src = 'assets/favicon_64.png';

// Audio
function playSound(type) {
    stopSound();
    if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();

    const gain = audioCtx.createGain();
    gain.gain.value = volume * 0.4;
    gain.connect(audioCtx.destination);

    document.getElementById('sound-badge').style.display = 'block';

    if (type === 'drone') {
        const o1 = audioCtx.createOscillator();
        const o2 = audioCtx.createOscillator();
        o1.type = 'sawtooth'; o1.frequency.value = 55;
        o2.type = 'sine'; o2.frequency.value = 58;
        o1.connect(gain); o2.connect(gain);
        o1.start(); o2.start();
        soundNodes = [o1, o2, gain];
    } else if (type === 'noise') {
        const buf = audioCtx.createBuffer(1, audioCtx.sampleRate * 2, audioCtx.sampleRate);
        const d = buf.getChannelData(0);
        for (let i = 0; i < d.length; i++) d[i] = Math.random() * 2 - 1;
        const src = audioCtx.createBufferSource();
        src.buffer = buf; src.loop = true;
        src.connect(gain); src.start();
        soundNodes = [src, gain];
    } else if (type === 'pulse') {
        const o = audioCtx.createOscillator();
        o.type = 'sine'; o.frequency.value = 432;
        const lfo = audioCtx.createOscillator();
        const lfoG = audioCtx.createGain();
        lfo.frequency.value = 2; lfoG.gain.value = 0.4;
        lfo.connect(lfoG); lfoG.connect(gain.gain);
        o.connect(gain); o.start(); lfo.start();
        soundNodes = [o, lfo, gain];
    } else if (type === 'chaos') {
        // Chaotic multi-oscillator madness
        const oscs = [];
        for (let j = 0; j < 4; j++) {
            const o = audioCtx.createOscillator();
            o.type = ['sawtooth', 'square', 'triangle', 'sine'][j];
            o.frequency.value = 40 + Math.random() * 200;
            o.connect(gain);
            o.start();
            oscs.push(o);
            // Randomly modulate frequency
            setInterval(() => {
                if (o.frequency) o.frequency.value = 30 + Math.random() * 300;
            }, 100);
        }
        // Add noise layer
        const buf = audioCtx.createBuffer(1, audioCtx.sampleRate, audioCtx.sampleRate);
        const d = buf.getChannelData(0);
        for (let j = 0; j < d.length; j++) d[j] = Math.random() * 2 - 1;
        const noiseSrc = audioCtx.createBufferSource();
        noiseSrc.buffer = buf; noiseSrc.loop = true;
        const noiseGain = audioCtx.createGain();
        noiseGain.gain.value = 0.3;
        noiseSrc.connect(noiseGain);
        noiseGain.connect(gain);
        noiseSrc.start();
        soundNodes = [...oscs, noiseSrc, gain];
    }
}

function stopSound() {
    document.getElementById('sound-badge').style.display = 'none';
    if (soundNodes) {
        soundNodes.forEach(n => { try { n.stop ? n.stop() : null; } catch(e){} });
        soundNodes = null;
    }
}

// Animations
function animate(ctx, type, t, sz) {
    const i = intensity;
    const h = sz / 2;

    ctx.clearRect(0, 0, sz, sz);
    ctx.save();
    ctx.translate(h, h);

    switch(type) {
        case 'pulse':
            const ps = 0.8 + 0.2 * Math.sin(t * Math.PI) * i;
            ctx.scale(ps, ps);
            ctx.globalAlpha = 0.6 + 0.4 * Math.sin(t * Math.PI);
            break;
        case 'heartbeat':
            const b = t % 1;
            let hs = 1;
            if (b < 0.1) hs = 1 + 0.25 * Math.sin(b * 10 * Math.PI) * i;
            else if (b < 0.3) hs = 1 + 0.15 * Math.sin((b-0.1) * 5 * Math.PI) * i;
            ctx.scale(hs, hs);
            break;
        case 'spin':
            ctx.rotate(t * Math.PI * 2 * i);
            break;
        case 'bounce':
            ctx.translate(0, -8 * Math.abs(Math.sin(t * 4 * Math.PI)) * i);
            const bs = 1 + 0.15 * Math.abs(Math.sin(t * 4 * Math.PI)) * i;
            ctx.scale(bs, 1/bs);
            break;
        case 'drunk':
            ctx.translate(Math.sin(t * 2) * 5 * i, Math.cos(t * 3) * 3 * i);
            ctx.rotate(Math.sin(t * 1.5) * 0.25 * i);
            break;
        case 'glitch':
            if (Math.random() < 0.4 * i) {
                ctx.translate((Math.random()-0.5) * 10 * i, (Math.random()-0.5) * 10 * i);
            }
            break;
        case 'fire':
            ctx.translate((Math.random()-0.5) * 4 * i, (Math.random()-0.5) * 4 * i);
            const fireScale = 1 + (Math.random() - 0.5) * 0.2 * i;
            ctx.scale(fireScale, fireScale * (1 + Math.random() * 0.1 * i));
            break;
        case 'matrix':
            // Matrix uses post-processing, add intensity-affected flicker and slight distortion
            ctx.globalAlpha = 1 - (Math.random() * 0.2 * i);
            ctx.translate((Math.random()-0.5) * 2 * i, (Math.random()-0.5) * 2 * i);
            break;
        case 'earthquake':
            ctx.translate((Math.random()-0.5) * 14 * i, (Math.random()-0.5) * 14 * i);
            ctx.rotate((Math.random()-0.5) * 0.4 * i);
            break;
        case 'meltdown':
            const sk = Math.sin(t * 2) * 0.4 * i;
            ctx.transform(1, sk, 0, 1 + Math.abs(sk) * 0.5, 0, 0);
            break;
        case 'possessed':
            ctx.translate((Math.random()-0.5) * 8 * i, (Math.random()-0.5) * 8 * i);
            if (Math.random() < 0.15) ctx.scale(-1, 1);
            break;
        case 'static':
            ctx.translate((Math.random()-0.5) * 6 * i, (Math.random()-0.5) * 6 * i);
            ctx.globalAlpha = 0.6 + Math.random() * 0.4;
            break;
        case 'hypnotic':
            ctx.rotate(t * Math.PI * i);
            const hypScale = 1 - (0.15 * Math.sin(t * 4) * i);
            ctx.scale(hypScale, hypScale);
            break;
        case 'nightmare':
            // TOTAL CHAOS - speed controls how many transforms, intensity controls magnitude
            const chaosLoops = Math.ceil(speed * 1.5);
            for (let c = 0; c < chaosLoops; c++) {
                const nx = (Math.random() - 0.5) * 25 * i;
                const ny = (Math.random() - 0.5) * 25 * i;
                const nRot = (Math.random() - 0.5) * Math.PI * i * speed;
                const nScale = 1 + (Math.random() - 0.5) * 1.5 * i;
                const nSkewX = (Math.random() - 0.5) * i;
                const nSkewY = (Math.random() - 0.5) * i;
                ctx.translate(nx / chaosLoops, ny / chaosLoops);
                ctx.rotate(nRot / chaosLoops);
                ctx.scale(nScale, nScale * (0.7 + Math.random() * 0.6 * i));
                ctx.transform(1, nSkewX / chaosLoops, nSkewY / chaosLoops, 1, 0, 0);
            }
            ctx.globalAlpha = Math.max(0.1, 1 - Math.random() * 0.8 * i);
            if (Math.random() < 0.2 * i * speed) ctx.scale(-1, 1);
            if (Math.random() < 0.15 * i * speed) ctx.scale(1, -1);
            break;
    }

    ctx.drawImage(img, -h, -h, sz, sz);
    ctx.restore();

    // Post effects
    if (['glitch','fire','matrix','meltdown','possessed','static','hypnotic','nightmare'].includes(type)) {
        try {
            const imgData = ctx.getImageData(0, 0, sz, sz);
            const d = imgData.data;

            if (type === 'glitch') {
                const shift = Math.floor(Math.random() * 8 * i);
                for (let j = 0; j < d.length - shift*4; j += 4) d[j] = d[j + shift*4];
            } else if (type === 'fire') {
                const fireIntensity = 1 + 0.4 * i;
                for (let j = 0; j < d.length; j += 4) {
                    d[j] = Math.min(255, d[j] * fireIntensity);
                    d[j+1] = Math.min(255, d[j+1] * (0.6 + 0.3 * i));
                    d[j+2] = d[j+2] * Math.max(0.1, 0.5 - 0.3 * i);
                }
            } else if (type === 'matrix') {
                // Green tint with intensity
                const greenBoost = 40 + 40 * i;
                for (let j = 0; j < d.length; j += 4) {
                    const l = (d[j] + d[j+1] + d[j+2]) / 3;
                    d[j] = l * (0.2 - 0.1 * i);
                    d[j+1] = Math.min(255, l * (0.6 + 0.3 * i) + greenBoost);
                    d[j+2] = l * (0.2 - 0.1 * i);
                }
                // Falling rain columns - speed and density affected by intensity
                const rainDensity = Math.max(1, Math.floor(4 - 2 * i));
                for (let x = 0; x < sz; x += rainDensity) {
                    const rainY = Math.floor((t * (30 + 20 * speed) + x * 13) % sz);
                    const trailLen = Math.floor(4 + 4 * i);
                    for (let dy = 0; dy < trailLen; dy++) {
                        const y = (rainY + dy) % sz;
                        const idx = (y * sz + x) * 4;
                        const brightness = (255 - dy * (200 / trailLen)) * i;
                        d[idx + 1] = Math.min(255, d[idx + 1] + brightness);
                    }
                }
            } else if (type === 'meltdown') {
                for (let y = sz-1; y > 0; y--) {
                    for (let x = 0; x < sz; x++) {
                        const idx = (y * sz + x) * 4;
                        const srcY = Math.max(0, y - Math.floor(Math.sin(x*0.5+t*3) * 4 * i));
                        const srcIdx = (srcY * sz + x) * 4;
                        d[idx] = d[idx]*0.7 + d[srcIdx]*0.3;
                        d[idx+1] = d[idx+1]*0.7 + d[srcIdx+1]*0.3;
                        d[idx+2] = d[idx+2]*0.7 + d[srcIdx+2]*0.3;
                    }
                }
            } else if (type === 'possessed') {
                if (Math.random() < 0.15 * i) {
                    for (let j = 0; j < d.length; j += 4) {
                        d[j] = 255-d[j]; d[j+1] = 255-d[j+1]; d[j+2] = 255-d[j+2];
                    }
                }
                const redBoost = 1 + 0.4 * i;
                const blueReduce = 0.8 - 0.3 * i;
                for (let j = 0; j < d.length; j += 4) {
                    d[j] = Math.min(255, d[j] * redBoost);
                    d[j+2] = d[j+2] * blueReduce;
                }
            } else if (type === 'static') {
                for (let j = 0; j < d.length; j += 4) {
                    const n = (Math.random()-0.5) * 200 * i;
                    d[j] = Math.max(0, Math.min(255, d[j]+n));
                    d[j+1] = Math.max(0, Math.min(255, d[j+1]+n));
                    d[j+2] = Math.max(0, Math.min(255, d[j+2]+n));
                }
            } else if (type === 'hypnotic') {
                const cx = sz/2, cy = sz/2;
                for (let y = 0; y < sz; y++) {
                    for (let x = 0; x < sz; x++) {
                        const dx = x-cx, dy = y-cy;
                        const ang = Math.atan2(dy, dx);
                        const dist = Math.sqrt(dx*dx + dy*dy);
                        const sp = Math.sin(ang*4 + dist*0.4 - t*6) * 0.5 + 0.5;
                        const idx = (y*sz + x) * 4;
                        d[idx] = d[idx] * (1-sp*0.5*i) + 150 * sp * 0.5 * i;
                        d[idx+2] = d[idx+2] * (1-sp*0.5*i) + 200 * sp * 0.5 * i;
                    }
                }
            } else if (type === 'nightmare') {
                // Speed controls number of effects, intensity controls their magnitude
                const numEffects = Math.ceil(speed * i * 2);
                for (let e = 0; e < numEffects; e++) {
                    const effect = Math.floor(Math.random() * 6);
                    switch(effect) {
                        case 0: // Full invert
                            if (Math.random() < 0.2 + 0.3 * i * speed) {
                                for (let j = 0; j < d.length; j += 4) {
                                    d[j] = 255 - d[j];
                                    d[j+1] = 255 - d[j+1];
                                    d[j+2] = 255 - d[j+2];
                                }
                            }
                            break;
                        case 1: // Extreme color shift
                            const hue = Math.random() * 360 * speed;
                            for (let j = 0; j < d.length; j += 4) {
                                const temp = d[j];
                                d[j] = d[j + (Math.floor(hue/120) % 3)];
                                d[j+1] = d[j + ((Math.floor(hue/120) + 1) % 3)];
                                d[j+2] = temp;
                            }
                            break;
                        case 2: // Posterize - threshold varies with intensity and speed
                            const threshold = Math.max(1, Math.floor(256 / (1 + i * speed * 3)));
                            for (let j = 0; j < d.length; j += 4) {
                                d[j] = Math.floor(d[j] / threshold) * threshold;
                                d[j+1] = Math.floor(d[j+1] / threshold) * threshold;
                                d[j+2] = Math.floor(d[j+2] / threshold) * threshold;
                            }
                            break;
                        case 3: // Channel chaos - shift scales with speed and intensity
                            const shift = Math.floor(Math.random() * 25 * i * speed + 3);
                            for (let j = 0; j < d.length - shift*4; j += 4) {
                                d[j] = d[j + shift * 4];
                                d[j+2] = d[Math.max(0, j - shift * 4) + 2];
                            }
                            break;
                        case 4: // Scanline hell - density scales with speed and intensity
                            for (let y = 0; y < sz; y++) {
                                if (Math.random() < 0.1 + 0.3 * i * speed) {
                                    for (let x = 0; x < sz; x++) {
                                        const idx = (y * sz + x) * 4;
                                        const v = Math.random() * 255;
                                        d[idx] = v; d[idx+1] = v; d[idx+2] = v;
                                    }
                                }
                            }
                            break;
                        case 5: // Noise blast - coverage scales with speed and intensity
                            const noiseChance = 0.15 + 0.35 * i * speed;
                            for (let j = 0; j < d.length; j += 4) {
                                if (Math.random() < noiseChance) {
                                    d[j] = Math.random() * 255;
                                    d[j+1] = Math.random() * 255;
                                    d[j+2] = Math.random() * 255;
                                }
                            }
                            break;
                    }
                }
            }

            ctx.putImageData(imgData, 0, 0);
        } catch(e) {}
    }
}

// Main loop
let lastFavUpdate = 0;
function loop(ts) {
    const t = ts / 1000 * speed;

    [64, 32, 16].forEach(sz => {
        const canvas = document.getElementById('preview-' + sz);
        if (canvas) animate(canvas.getContext('2d'), current, t, sz);
    });

    // Update favicon
    if (ts - lastFavUpdate > 50) {
        const c = document.getElementById('preview-32');
        const url = c.toDataURL('image/png');
        document.querySelectorAll("link[rel*='icon']").forEach(l => l.remove());
        const link = document.createElement('link');
        link.rel = 'icon';
        link.href = url;
        document.head.appendChild(link);
        lastFavUpdate = ts;
    }

    requestAnimationFrame(loop);
}

// UI
function setAnim(id) {
    const a = ANIMS.find(x => x.id === id);
    current = id;

    document.querySelectorAll('.btn-grid button').forEach(b => b.classList.remove('active'));
    document.getElementById('btn-' + id).classList.add('active');
    document.getElementById('current-name').textContent = a.name;

    stopSound();
    if (a.sound) playSound(a.sound);
}

// Init
img.onload = function() {
    // Create buttons
    const grid = document.getElementById('buttons');
    ANIMS.forEach(a => {
        const btn = document.createElement('button');
        btn.id = 'btn-' + a.id;
        btn.textContent = a.name;
        btn.onclick = () => setAnim(a.id);
        if (a.sound) btn.classList.add('sound');
        if (a.chaos) btn.classList.add('chaos');
        if (a.id === 'none') btn.classList.add('active');
        grid.appendChild(btn);
    });

    // Draw initial
    [64, 32, 16].forEach(sz => {
        const c = document.getElementById('preview-' + sz);
        c.getContext('2d').drawImage(img, 0, 0, sz, sz);
    });

    // Start loop
    requestAnimationFrame(loop);
};

img.onerror = function() {
    alert('Failed to load favicon image!');
};

// Sliders
document.getElementById('speed').oninput = e => {
    speed = parseFloat(e.target.value);
    document.getElementById('speed-val').textContent = speed.toFixed(1) + 'x';
};
document.getElementById('intensity').oninput = e => {
    intensity = parseFloat(e.target.value);
    document.getElementById('intensity-val').textContent = Math.round(intensity * 100) + '%';
};
document.getElementById('volume').oninput = e => {
    volume = parseFloat(e.target.value);
    document.getElementById('volume-val').textContent = Math.round(volume * 100) + '%';
    if (soundNodes && soundNodes[soundNodes.length-1].gain) {
        soundNodes[soundNodes.length-1].gain.value = volume * 0.4;
    }
};
</script>
</body>
</html>
